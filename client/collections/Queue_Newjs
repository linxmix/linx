/** @jsx React.DOM */
var debug = require('debug')('views:bars/sound/SoundBar');
var React = require('react');
var ReactBackboneMixin = require('backbone-react-component').mixin;

var Tab = require('../nav/Tab');

var Widgets = require('../../../collections/Widgets');
var WidgetsView = require('./Widgets');

// TODO: make soundbar not cover main section
module.exports = React.createClass({
  
  mixins: [ReactBackboneMixin],

  handleClick: function (soundTab) {
    this.props.changePlayState(soundTab.key);
  },

  getDefaultProps: function () {
    return {
      soundTabs: [
        {key: 'play', name: 'Play'},
        {key: 'pause', name: 'Pause'},
      ],
      initialWidgets: [
        {soundBarId: 'widget0', index: 0},
        {soundBarId: 'widget1', index: 1},
        {soundBarId: 'widget2', index: 2},
      ],
    }
  },

  getInitialState: function () {
    return {
      activeWidget: 0,
    }
  },

  setActiveWidget: function (newWidget) {
    debug("setActiveWidget: " + newWidget);
    this.setState({
      activeWidget: newWidget,
    });
  },

  assertPlayState: function () {
    var playState = this.props.playState;
    debug('asserting play state: ' + playState);
    var widgets = this.getCollection().widgets;
    var widgetModel = widgets.models[this.state.activeWidget];
    (widgetModel && widgetModel.assertPlayState(playState));
  },

  // TODO: add ability to reorder widgets
  // use queue to preload widgets
  isSyncing: false,
  syncQueue: function (action, track, index) {
    // TODO: see if this isSyncing thing does anything
    if (this.isSyncing) { return; }
    this.isSyncing = true;

    debug("syncQueue called", action, track, index);
    var activeWidget = this.state.activeWidget;
    var queue = this.getCollection().queue;
    var widgets = this.props.widgets;

    // if adding to front, decrement activeWidget
    if (action === 'add' && index === 0) {
      activeWidget = mod(activeWidget - 1, widgets.length);
      this.setActiveWidget(activeWidget);
    }

    // if removing from front, increment activeWidget
    else if (action === 'remove' && index === 0) {
      activeWidget = mod(activeWidget + 1, widgets.length);
      this.setActiveWidget(activeWidget);
    }

    // now do the queue sync
    // make sure each widget has correct track loaded
    widgets.forEach(function (widget) {
      var widgetIndex = widget.get('index');
      var queueIndex = (widgetIndex + activeWidget) % widgets.length;
            console.log("CALCULATION", widgetIndex, )

      // quit if queue index is beyond queue
      if (queueIndex >= queue.length) { return; }

      // if incorrect track, load correct track
      var track = queue.models[queueIndex];
      var trackId = track.get('id');
      var widgetTrack = widget.get('track');
      if (trackId !== (widgetTrack && widgetTrack.get('id'))) {
        console.log("widget and track were unsynced:",
          widget.get('index'), track.get('title'));
        widget.load(track, {
          'callback': this.assertPlayState,
        });
      }

    }.bind(this)); // /end sync

    this.isSyncing = false;

  },

  render: function () {

    // make soundTabs
    var soundTabs = this.props.soundTabs.map(function(soundTab) {
      return (
        Tab({
          'active': (soundTab.key === this.props.playState),
          'key': soundTab.key,
          'name': soundTab.name,
          'activeClass': 'active item',
          'inactiveClass': 'item',
          'handleClick': this.handleClick,
        })
      )
    }.bind(this));

    // make WidgetsView
    var widgetsView = WidgetsView({
      'widgets': this.props.widgets,
      'activeWidget': this.state.activeWidget,
      'setActiveWidget': this.setActiveWidget,
      'playState': this.props.playState,
      'changePlayState': this.props.changePlayState,
    });

    // render SoundBar
    return (
      <div className="inverted ui segment">
        {widgetsView}
      </div>
    )
  },

  // rendered component has been mounted to a DOM element
  componentDidMount: function () {
    debug("component mounted");

    // setup queue listeners
    var queue = this.getCollection().queue;
    queue.on('add', function (track, collection, options) {
      this.assertPlayState();
      return this.syncQueue('add', track, collection.indexOf(track));
    }.bind(this));
    queue.on('remove', function (track, collection, options) {
      this.assertPlayState();
      return this.syncQueue('remove', track, options.index);
    }.bind(this));
  },

});

// hand-made mod since javascript's % doesn't play with negative numbers
function mod(x, n) {
  return ((x % n) + n) % n;
}

/*


  // add track to head of queue and play
  play: function(e) {
    var track = this.props.track;
    debug("queueing and playing track", track);
    var queue = this.getCollection().queue;
    queue.unshift(track);
    this.props.changePlayState('play');
  },

  // queue this track by adding to back of queue
  queue: function(e) {
    var track = this.props.track;
    debug("queueing track", track);
    var queue = this.getCollection().queue;
    queue.push(track);
  },

  // remove track from queue
  dequeue: function(e) {
    var track = this.props.track;
    debug("dequeueing track", track);
    var queue = this.getCollection().queue;
    var index = queue.models.indexOf(track);
    queue.remove(track);
  },

  // TODO
  // view this track
  viewTrack: function () {
    var track = this.props.track;
    debug("viewing track", track);
  },
*/